using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

using ComLib;
using ComLib.Models;


namespace ComLib.CodeGeneration
{
    /// <summary>
    /// Helper class for code generation.
    /// </summary>
    public class CodeFileHelper
    {

        /// <summary>
        /// Writes out the autogenerated file, after processing the substitutions.
        /// </summary>
        /// <param name="templateFile">The name of the initial template file.</param>
        /// <param name="generatedFile">The full location of the file to generate.</param>
        /// <param name="generatedFileDirectory">The location of the directory to put the autogenerated file.</param>
        /// <param name="substitutions">The substituions (key/value) pairs.</param>
        public static void Write(string templateFile, string generatedFile, string generatedFileDirectory, IDictionary<string, string> substitutions)
        {
            // Read in the input / template file.
            string fileContent = File.ReadAllText(templateFile);

            // Create the directory if it doesn't exist.
            if (!Directory.Exists(generatedFileDirectory))
                Directory.CreateDirectory(generatedFileDirectory);

            // Replace the values.
            IEnumerator<KeyValuePair<string, string>> enumerator = substitutions.GetEnumerator();
            while(enumerator.MoveNext())
                fileContent = fileContent.Replace(enumerator.Current.Key, enumerator.Current.Value);

            // Write out the generated file.
            File.WriteAllText(generatedFile, fileContent);
        }


        /// <summary>
        /// Get the names of all the procedures in the stored proc template folder
        /// </summary>
        /// <param name="codeTemplatePath"></param>
        /// <returns></returns>
        public static List<string> GetProcNames(string codeTemplatePath)
        {            
            string[] files = Directory.GetFiles(codeTemplatePath);
            if (files == null || files.Length == 0)
                return new List<string>();

            List<FileInfo> fileInfos = new List<FileInfo>();
            Dictionary<string, string> fileMap = new Dictionary<string, string>();

            files.ForEach(f => fileInfos.Add(new FileInfo(f)));

            StringBuilder buffer = new StringBuilder();
            List<string> procNames = new List<string>();

            // Get each stored proc and do substitutions.
            foreach (FileInfo file in fileInfos)
            {
                string fileContent = File.ReadAllText(file.FullName);

                // Determine stored proc name.
                // 01234567890
                //    cde_ad]
                string nameCheck = @"CREATE PROCEDURE [dbo].[<%= model.TableName %>_";
                int ndxProcName = fileContent.IndexOf(nameCheck);
                ndxProcName = ndxProcName + nameCheck.Length;
                int nextBracket = fileContent.IndexOf("]", ndxProcName);
                string procName = fileContent.Substring(ndxProcName, (nextBracket - ndxProcName));
                procNames.Add(procName);                
            }
            return procNames;
        }



        /// <summary>
        /// Get all the files that are applicable for code-generation for the specified model.
        /// </summary>
        /// <param name="currentModel"></param>
        /// <param name="allFiles"></param>
        /// <returns></returns>
        public static Dictionary<string, CodeFile> GetFilteredDomainModelFiles(Model currentModel, Dictionary<string, CodeFile> allFiles)
        {
            IDictionary<string, string> excludedFiles = new Dictionary<string, string>();
            if (!string.IsNullOrEmpty(currentModel.ExcludeFiles))
                excludedFiles = currentModel.ExcludeFiles.Split(',').ToDictionary();

            Dictionary<string, CodeFile> fileMap = new Dictionary<string, CodeFile>();
            foreach(KeyValuePair<string, CodeFile> file in allFiles.AsEnumerable())
            {
                // If not in exclude list, store the name of the file.                
                if (!excludedFiles.ContainsKey(file.Key))
                {
                    fileMap[file.Key] = file.Value;
                    fileMap[file.Key].QualifiedName = currentModel.Name + file.Key;
                }
            }
            // The file names are copied and renamed to be associated with the model.                    
            if (fileMap.ContainsKey("Entity.cs")) fileMap["Entity.cs"].QualifiedName = currentModel.Name + ".cs";
            if (fileMap.ContainsKey("ActiveRecord.cs")) fileMap["ActiveRecord.cs"].QualifiedName = currentModel.Name + "s.cs";
            if (fileMap.ContainsKey("Service.cs")) fileMap["Service.cs"].QualifiedName = currentModel.Name + "Service.cs";
            if (fileMap.ContainsKey("Repository.cs")) fileMap["Repository.cs"].QualifiedName = currentModel.Name + "Repository.cs";
            if (fileMap.ContainsKey("Validator.cs")) fileMap["Validator.cs"].QualifiedName = currentModel.Name + "Validator.cs";
            if (fileMap.ContainsKey("Settings.cs")) fileMap["Settings.cs"].QualifiedName = currentModel.Name + "Settings.cs";
            if (fileMap.ContainsKey("Resources.cs")) fileMap["Resources.cs"].QualifiedName = currentModel.Name + "Resources.cs";
            if (fileMap.ContainsKey("ImportExport.cs")) fileMap["ImportExport.cs"].QualifiedName = currentModel.Name + "ImportExport.cs";
            if (fileMap.ContainsKey("Feeds.cs")) fileMap["Feeds.cs"].QualifiedName = currentModel.Name + "Feeds.cs";
            if (fileMap.ContainsKey("Serializer.cs")) fileMap["Serializer.cs"].QualifiedName = currentModel.Name + "Serializer.cs";
            if (fileMap.ContainsKey("RepositorySql.cs")) fileMap["RepositorySql.cs"].QualifiedName = currentModel.Name + "RepositorySql.cs";
            string repositoryToRemove = "RepositorySql.cs";
            if (currentModel.RepositoryType.ToLower() == "repositorysql") repositoryToRemove = "Repository.cs";
            if (fileMap.ContainsKey(repositoryToRemove)) fileMap.Remove(repositoryToRemove);
            return fileMap;
        }
    }
}
